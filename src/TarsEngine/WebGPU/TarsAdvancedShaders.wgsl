// TARS Advanced WebGPU Shaders
// High-performance shaders for 3D interface rendering
// Autonomously generated by TARS AI Engine

// ============================================================================
// VERTEX SHADER STRUCTURES
// ============================================================================

struct VertexInput {
    @location(0) position: vec3<f32>,
    @location(1) normal: vec3<f32>,
    @location(2) uv: vec2<f32>,
    @location(3) color: vec3<f32>,
}

struct VertexOutput {
    @builtin(position) clip_position: vec4<f32>,
    @location(0) world_position: vec3<f32>,
    @location(1) world_normal: vec3<f32>,
    @location(2) uv: vec2<f32>,
    @location(3) color: vec3<f32>,
    @location(4) view_position: vec3<f32>,
}

struct Uniforms {
    model_matrix: mat4x4<f32>,
    view_matrix: mat4x4<f32>,
    projection_matrix: mat4x4<f32>,
    normal_matrix: mat3x3<f32>,
    camera_position: vec3<f32>,
    time: f32,
    tars_humor: f32,
    tars_honesty: f32,
}

struct LightingData {
    ambient_color: vec3<f32>,
    light_direction: vec3<f32>,
    light_color: vec3<f32>,
    light_intensity: f32,
    tars_glow_intensity: f32,
    hologram_opacity: f32,
}

@group(0) @binding(0) var<uniform> uniforms: Uniforms;
@group(0) @binding(1) var<uniform> lighting: LightingData;
@group(0) @binding(2) var base_texture: texture_2d<f32>;
@group(0) @binding(3) var base_sampler: sampler;
@group(0) @binding(4) var normal_texture: texture_2d<f32>;
@group(0) @binding(5) var metallic_roughness_texture: texture_2d<f32>;

// ============================================================================
// TARS ROBOT VERTEX SHADER
// ============================================================================

@vertex
fn tars_robot_vertex(input: VertexInput) -> VertexOutput {
    var output: VertexOutput;
    
    // Apply model transformations
    let world_position = uniforms.model_matrix * vec4<f32>(input.position, 1.0);
    let view_position = uniforms.view_matrix * world_position;
    
    // TARS personality-based deformation
    let humor_factor = sin(uniforms.time * 2.0 + input.position.y * 5.0) * uniforms.tars_humor * 0.01;
    let honesty_displacement = uniforms.tars_honesty * 0.005;
    
    // Apply subtle personality-based vertex displacement
    var displaced_position = input.position;
    displaced_position.x += humor_factor;
    displaced_position.z += honesty_displacement * sin(uniforms.time + input.position.y * 3.0);
    
    let final_world_position = uniforms.model_matrix * vec4<f32>(displaced_position, 1.0);
    
    output.clip_position = uniforms.projection_matrix * uniforms.view_matrix * final_world_position;
    output.world_position = final_world_position.xyz;
    output.world_normal = uniforms.normal_matrix * input.normal;
    output.uv = input.uv;
    output.color = input.color;
    output.view_position = view_position.xyz;
    
    return output;
}

// ============================================================================
// TARS ROBOT FRAGMENT SHADER
// ============================================================================

@fragment
fn tars_robot_fragment(input: VertexOutput) -> @location(0) vec4<f32> {
    let base_color = textureSample(base_texture, base_sampler, input.uv);
    let normal_map = textureSample(normal_texture, base_sampler, input.uv);
    let metallic_roughness = textureSample(metallic_roughness_texture, base_sampler, input.uv);
    
    // Unpack normal from normal map
    let normal = normalize(input.world_normal);
    let tangent_normal = normal_map.xyz * 2.0 - 1.0;
    
    // Calculate lighting
    let light_dir = normalize(-lighting.light_direction);
    let view_dir = normalize(uniforms.camera_position - input.world_position);
    let half_dir = normalize(light_dir + view_dir);
    
    // Diffuse lighting
    let ndotl = max(dot(normal, light_dir), 0.0);
    let diffuse = lighting.light_color * ndotl * lighting.light_intensity;
    
    // Specular lighting (Blinn-Phong)
    let ndoth = max(dot(normal, half_dir), 0.0);
    let roughness = metallic_roughness.g;
    let shininess = (1.0 - roughness) * 128.0;
    let specular = lighting.light_color * pow(ndoth, shininess) * lighting.light_intensity;
    
    // Metallic workflow
    let metallic = metallic_roughness.b;
    let dielectric_specular = vec3<f32>(0.04);
    let f0 = mix(dielectric_specular, base_color.rgb, metallic);
    
    // Fresnel effect
    let vdoth = max(dot(view_dir, half_dir), 0.0);
    let fresnel = f0 + (1.0 - f0) * pow(1.0 - vdoth, 5.0);
    
    // TARS personality glow
    let humor_glow = sin(uniforms.time * 3.0) * uniforms.tars_humor * 0.1;
    let honesty_pulse = (sin(uniforms.time * 1.5) + 1.0) * 0.5 * uniforms.tars_honesty * 0.05;
    let personality_glow = vec3<f32>(0.0, 0.8, 1.0) * (humor_glow + honesty_pulse);
    
    // TARS signature blue glow
    let tars_glow = vec3<f32>(0.0, 0.6, 1.0) * lighting.tars_glow_intensity;
    let glow_factor = 1.0 + sin(uniforms.time * 2.0) * 0.2;
    
    // Combine lighting
    let ambient = lighting.ambient_color * base_color.rgb;
    let final_color = ambient + diffuse * base_color.rgb + specular * fresnel + personality_glow + tars_glow * glow_factor;
    
    return vec4<f32>(final_color, base_color.a);
}

// ============================================================================
// HOLOGRAPHIC UI VERTEX SHADER
// ============================================================================

@vertex
fn hologram_vertex(input: VertexInput) -> VertexOutput {
    var output: VertexOutput;
    
    // Holographic distortion effect
    let distortion = sin(uniforms.time * 4.0 + input.position.y * 10.0) * 0.02;
    let scan_line = sin(input.position.y * 50.0 + uniforms.time * 10.0) * 0.01;
    
    var distorted_position = input.position;
    distorted_position.x += distortion;
    distorted_position.z += scan_line;
    
    let world_position = uniforms.model_matrix * vec4<f32>(distorted_position, 1.0);
    
    output.clip_position = uniforms.projection_matrix * uniforms.view_matrix * world_position;
    output.world_position = world_position.xyz;
    output.world_normal = uniforms.normal_matrix * input.normal;
    output.uv = input.uv;
    output.color = input.color;
    output.view_position = (uniforms.view_matrix * world_position).xyz;
    
    return output;
}

// ============================================================================
// HOLOGRAPHIC UI FRAGMENT SHADER
// ============================================================================

@fragment
fn hologram_fragment(input: VertexOutput) -> @location(0) vec4<f32> {
    let base_color = textureSample(base_texture, base_sampler, input.uv);
    
    // Holographic scan lines
    let scan_line = sin(input.uv.y * 100.0 + uniforms.time * 15.0);
    let scan_intensity = (scan_line + 1.0) * 0.5;
    
    // Holographic flicker
    let flicker = sin(uniforms.time * 30.0) * 0.1 + 0.9;
    
    // Edge glow effect
    let edge_factor = 1.0 - abs(input.uv.x - 0.5) * 2.0;
    let edge_glow = pow(edge_factor, 3.0);
    
    // Holographic color
    let holo_color = vec3<f32>(0.0, 1.0, 1.0);
    let final_color = mix(base_color.rgb, holo_color, 0.7) * scan_intensity * flicker;
    
    // Apply holographic opacity with edge enhancement
    let opacity = lighting.hologram_opacity * (0.6 + edge_glow * 0.4) * flicker;
    
    return vec4<f32>(final_color + holo_color * edge_glow * 0.3, opacity);
}

// ============================================================================
// DATA VISUALIZATION VERTEX SHADER
// ============================================================================

@vertex
fn data_viz_vertex(input: VertexInput) -> VertexOutput {
    var output: VertexOutput;
    
    // Data-driven animation
    let data_value = input.color.r; // Use red channel as data value
    let animation_offset = sin(uniforms.time * 2.0 + data_value * 10.0) * data_value * 0.5;
    
    var animated_position = input.position;
    animated_position.y += animation_offset;
    
    // Pulsing scale based on data
    let scale_factor = 1.0 + data_value * 0.3 * sin(uniforms.time * 3.0);
    animated_position *= scale_factor;
    
    let world_position = uniforms.model_matrix * vec4<f32>(animated_position, 1.0);
    
    output.clip_position = uniforms.projection_matrix * uniforms.view_matrix * world_position;
    output.world_position = world_position.xyz;
    output.world_normal = uniforms.normal_matrix * input.normal;
    output.uv = input.uv;
    output.color = input.color;
    output.view_position = (uniforms.view_matrix * world_position).xyz;
    
    return output;
}

// ============================================================================
// DATA VISUALIZATION FRAGMENT SHADER
// ============================================================================

@fragment
fn data_viz_fragment(input: VertexOutput) -> @location(0) vec4<f32> {
    let data_value = input.color.r;
    
    // Performance-based color mapping
    let performance_color = mix(
        vec3<f32>(1.0, 0.0, 0.0), // Red for low performance
        vec3<f32>(0.0, 1.0, 0.0), // Green for high performance
        data_value
    );
    
    // Add energy effect
    let energy_pulse = sin(uniforms.time * 5.0 + data_value * 15.0) * 0.2 + 0.8;
    let final_color = performance_color * energy_pulse;
    
    // Distance-based opacity
    let distance = length(input.view_position);
    let distance_opacity = 1.0 - smoothstep(5.0, 15.0, distance);
    
    return vec4<f32>(final_color, distance_opacity * 0.8);
}

// ============================================================================
// SPACE ENVIRONMENT VERTEX SHADER
// ============================================================================

@vertex
fn space_vertex(input: VertexInput) -> VertexOutput {
    var output: VertexOutput;
    
    // Slowly rotating space environment
    let rotation_speed = uniforms.time * 0.1;
    let cos_rot = cos(rotation_speed);
    let sin_rot = sin(rotation_speed);
    
    var rotated_position = input.position;
    rotated_position.x = input.position.x * cos_rot - input.position.z * sin_rot;
    rotated_position.z = input.position.x * sin_rot + input.position.z * cos_rot;
    
    let world_position = uniforms.model_matrix * vec4<f32>(rotated_position, 1.0);
    
    output.clip_position = uniforms.projection_matrix * uniforms.view_matrix * world_position;
    output.world_position = world_position.xyz;
    output.world_normal = uniforms.normal_matrix * input.normal;
    output.uv = input.uv;
    output.color = input.color;
    output.view_position = (uniforms.view_matrix * world_position).xyz;
    
    return output;
}

// ============================================================================
// SPACE ENVIRONMENT FRAGMENT SHADER
// ============================================================================

@fragment
fn space_fragment(input: VertexOutput) -> @location(0) vec4<f32> {
    // Starfield effect
    let star_noise = fract(sin(dot(input.uv * 1000.0, vec2<f32>(12.9898, 78.233))) * 43758.5453);
    let star_threshold = 0.995;
    let star_intensity = step(star_threshold, star_noise);
    
    // Nebula effect
    let nebula_noise1 = sin(input.uv.x * 5.0 + uniforms.time * 0.5) * sin(input.uv.y * 3.0 + uniforms.time * 0.3);
    let nebula_noise2 = sin(input.uv.x * 8.0 - uniforms.time * 0.4) * sin(input.uv.y * 6.0 - uniforms.time * 0.2);
    let nebula = (nebula_noise1 + nebula_noise2) * 0.1 + 0.1;
    
    // Deep space colors
    let space_color = vec3<f32>(0.05, 0.05, 0.15);
    let nebula_color = vec3<f32>(0.2, 0.1, 0.4);
    let star_color = vec3<f32>(1.0, 1.0, 0.9);
    
    let final_color = space_color + nebula_color * nebula + star_color * star_intensity;
    
    return vec4<f32>(final_color, 1.0);
}

// ============================================================================
// PARTICLE SYSTEM COMPUTE SHADER
// ============================================================================

struct Particle {
    position: vec3<f32>,
    velocity: vec3<f32>,
    life: f32,
    size: f32,
}

@group(0) @binding(0) var<storage, read_write> particles: array<Particle>;

@compute @workgroup_size(64)
fn update_particles(@builtin(global_invocation_id) global_id: vec3<u32>) {
    let index = global_id.x;
    if (index >= arrayLength(&particles)) {
        return;
    }
    
    var particle = particles[index];
    
    // Update particle physics
    particle.position += particle.velocity * 0.016; // Assuming 60 FPS
    particle.velocity.y -= 9.81 * 0.016; // Gravity
    particle.life -= 0.016;
    
    // Reset particle if dead
    if (particle.life <= 0.0) {
        particle.position = vec3<f32>(
            (f32(index) % 100.0 - 50.0) * 0.1,
            10.0,
            (f32(index / 100u) % 100.0 - 50.0) * 0.1
        );
        particle.velocity = vec3<f32>(
            sin(f32(index) * 0.1) * 2.0,
            5.0 + sin(f32(index) * 0.2) * 2.0,
            cos(f32(index) * 0.1) * 2.0
        );
        particle.life = 5.0;
        particle.size = 0.1 + sin(f32(index) * 0.3) * 0.05;
    }
    
    particles[index] = particle;
}
