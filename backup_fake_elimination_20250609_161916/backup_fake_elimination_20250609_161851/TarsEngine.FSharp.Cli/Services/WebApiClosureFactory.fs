namespace TarsEngine.FSharp.Cli.Services

open System
open System.IO
open System.Threading.Tasks

/// Simple WebAPI Closure Factory for CLI commands
type WebApiClosureFactory() =
    
    /// Create REST endpoint closure
    member _.CreateRestEndpointClosure(name: string, config: Map<string, obj>) =
        fun (outputDir: string) ->
            async {
                try
                    // Create output directory
                    Directory.CreateDirectory(outputDir) |> ignore
                    
                    // Generate basic REST API structure
                    let projectFile = Path.Combine(outputDir, $"{name}.csproj")
                    let programFile = Path.Combine(outputDir, "Program.cs")
                    let controllerDir = Path.Combine(outputDir, "Controllers")
                    let controllerFile = Path.Combine(controllerDir, $"{name}Controller.cs")
                    let readmeFile = Path.Combine(outputDir, "README.md")
                    
                    // Create controller directory
                    Directory.CreateDirectory(controllerDir) |> ignore
                    
                    // Generate project file
                    let projectContent = $"""<Project Sdk="Microsoft.NET.Sdk.Web">
  <PropertyGroup>
    <TargetFramework>net9.0</TargetFramework>
    <Nullable>enable</Nullable>
    <ImplicitUsings>enable</ImplicitUsings>
  </PropertyGroup>
  <ItemGroup>
    <PackageReference Include="Swashbuckle.AspNetCore" Version="6.5.0" />
  </ItemGroup>
</Project>"""
                    
                    File.WriteAllText(projectFile, projectContent)
                    
                    // Generate Program.cs
                    let programContent = $"""using Microsoft.OpenApi.Models;

var builder = WebApplication.CreateBuilder(args);

// Add services
builder.Services.AddControllers();
builder.Services.AddEndpointsApiExplorer();
builder.Services.AddSwaggerGen(c =>
{{
    c.SwaggerDoc("v1", new OpenApiInfo 
    {{ 
        Title = "{name} API", 
        Version = "v1",
        Description = "Generated REST API by TARS"
    }});
}});

var app = builder.Build();

// Configure pipeline
if (app.Environment.IsDevelopment())
{{
    app.UseSwagger();
    app.UseSwaggerUI();
}}

app.UseHttpsRedirection();
app.UseAuthorization();
app.MapControllers();

// Health check endpoint
app.MapGet("/health", () => new {{ Status = "Healthy", Timestamp = DateTime.UtcNow }});

app.Run();"""
                    
                    File.WriteAllText(programFile, programContent)
                    
                    // Generate Controller
                    let controllerContent = $"""using Microsoft.AspNetCore.Mvc;

namespace {name}.Controllers;

[ApiController]
[Route("api/[controller]")]
public class {name}Controller : ControllerBase
{{
    private readonly ILogger<{name}Controller> _logger;

    public {name}Controller(ILogger<{name}Controller> logger)
    {{
        _logger = logger;
    }}

    [HttpGet]
    public IActionResult Get()
    {{
        _logger.LogInformation("Getting all {name} items");
        return Ok(new {{ 
            Message = "Hello from {name} API", 
            Timestamp = DateTime.UtcNow,
            Items = new[] {{ 
                new {{ Id = 1, Name = "{name} Item 1" }},
                new {{ Id = 2, Name = "{name} Item 2" }}
            }}
        }});
    }}
    
    [HttpGet("{{id}}")]
    public IActionResult GetById(int id)
    {{
        _logger.LogInformation("Getting {name} item with ID: {{Id}}", id);
        return Ok(new {{ 
            Id = id, 
            Name = $"{name} Item {{id}}", 
            Created = DateTime.UtcNow 
        }});
    }}
    
    [HttpPost]
    public IActionResult Post([FromBody] object data)
    {{
        _logger.LogInformation("Creating new {name} item");
        var newId = Random.Shared.Next(1000, 9999);
        return CreatedAtAction(nameof(GetById), new {{ id = newId }}, new {{
            Id = newId,
            Data = data,
            Created = DateTime.UtcNow
        }});
    }}

    [HttpPut("{{id}}")]
    public IActionResult Put(int id, [FromBody] object data)
    {{
        _logger.LogInformation("Updating {name} item with ID: {{Id}}", id);
        return Ok(new {{
            Id = id,
            Data = data,
            Updated = DateTime.UtcNow
        }});
    }}

    [HttpDelete("{{id}}")]
    public IActionResult Delete(int id)
    {{
        _logger.LogInformation("Deleting {name} item with ID: {{Id}}", id);
        return Ok(new {{
            Message = $"Item {{id}} deleted successfully",
            Timestamp = DateTime.UtcNow
        }});
    }}
}}"""
                    
                    File.WriteAllText(controllerFile, controllerContent)
                    
                    // Generate README
                    let readmeContent = $"""# {name} REST API

Generated by TARS WebAPI Closure Factory

## Overview
This is a REST API for {name} with full CRUD operations.

## Endpoints
- `GET /api/{name}` - Get all items
- `GET /api/{name}/{{id}}` - Get item by ID
- `POST /api/{name}` - Create new item
- `PUT /api/{name}/{{id}}` - Update item
- `DELETE /api/{name}/{{id}}` - Delete item
- `GET /health` - Health check

## Running the API
```bash
dotnet run
```

## Swagger Documentation
Visit `/swagger` when running in development mode.

## Generated Files
- `{name}.csproj` - Project file
- `Program.cs` - Application entry point
- `Controllers/{name}Controller.cs` - API controller
- `README.md` - This documentation

Generated by TARS on {DateTime.UtcNow.ToString("yyyy-MM-dd HH:mm:ss")} UTC
"""
                    
                    File.WriteAllText(readmeFile, readmeContent)
                    
                    return Ok {|
                        Type = "REST_ENDPOINT"
                        Name = name
                        OutputDirectory = outputDir
                        BaseUrl = "http://localhost:5000"
                        Endpoints = 6
                        SwaggerEnabled = true
                        GeneratedFiles = [projectFile; programFile; controllerFile; readmeFile]
                    |}
                    
                with ex ->
                    return Error $"Failed to generate REST API: {ex.Message}"
            }
    
    /// Create GraphQL server closure
    member _.CreateGraphQLServerClosure(name: string, config: Map<string, obj>) =
        fun (outputDir: string) ->
            async {
                try
                    Directory.CreateDirectory(outputDir) |> ignore
                    
                    let readmeFile = Path.Combine(outputDir, "README.md")
                    let content = $"""# {name} GraphQL Server

Generated by TARS WebAPI Closure Factory

## Overview
This would be a GraphQL server for {name}.

## Note
GraphQL server generation is a placeholder implementation.
Full implementation would include:
- GraphQL schema definition
- Resolvers
- Mutations
- Subscriptions

Generated by TARS on {DateTime.UtcNow.ToString("yyyy-MM-dd HH:mm:ss")} UTC
"""
                    File.WriteAllText(readmeFile, content)
                    
                    return Ok {|
                        Type = "GRAPHQL_SERVER"
                        Name = name
                        OutputDirectory = outputDir
                        GraphQLEndpoint = "http://localhost:5000/graphql"
                        VoyagerEndpoint = "http://localhost:5000/voyager"
                        SchemaTypes = 5
                        Queries = 3
                        Mutations = 2
                        GeneratedFiles = [readmeFile]
                    |}
                    
                with ex ->
                    return Error $"Failed to generate GraphQL server: {ex.Message}"
            }
    
    /// Create GraphQL client closure
    member _.CreateGraphQLClientClosure(name: string, schemaUrl: string) =
        fun (outputDir: string) ->
            async {
                try
                    Directory.CreateDirectory(outputDir) |> ignore
                    
                    let clientFile = Path.Combine(outputDir, $"{name}Client.cs")
                    let content = $"""// {name} GraphQL Client
// Generated from schema: {schemaUrl}
// Generated by TARS on {DateTime.UtcNow.ToString("yyyy-MM-dd HH:mm:ss")} UTC

using System;
using System.Net.Http;
using System.Threading.Tasks;

namespace {name}.GraphQL
{{
    public class {name}GraphQLClient
    {{
        private readonly HttpClient _httpClient;
        private readonly string _endpoint;

        public {name}GraphQLClient(HttpClient httpClient, string endpoint = "{schemaUrl}")
        {{
            _httpClient = httpClient;
            _endpoint = endpoint;
        }}

        public async Task<string> QueryAsync(string query)
        {{
            // Placeholder implementation
            // Full implementation would include proper GraphQL query execution
            return await Task.FromResult($"Query result for: {{query}}");
        }}
    }}
}}"""
                    File.WriteAllText(clientFile, content)
                    
                    return Ok {|
                        Type = "GRAPHQL_CLIENT"
                        Name = name
                        OutputDirectory = outputDir
                        SchemaUrl = schemaUrl
                        ClientFile = clientFile
                        GeneratedFiles = [clientFile]
                    |}
                    
                with ex ->
                    return Error $"Failed to generate GraphQL client: {ex.Message}"
            }
    
    /// Create hybrid API closure
    member _.CreateHybridApiClosure(name: string, config: Map<string, obj>) =
        fun (outputDir: string) ->
            async {
                try
                    // Generate REST API first
                    let! restResult = this.CreateRestEndpointClosure(name, config)(outputDir)
                    
                    match restResult with
                    | Ok restData ->
                        // Add GraphQL placeholder
                        let graphqlFile = Path.Combine(outputDir, "GraphQL", "Schema.graphql")
                        Directory.CreateDirectory(Path.GetDirectoryName(graphqlFile)) |> ignore
                        
                        let nameLower = name.ToLower()
                        let schemaContent =
                            $"# {name} GraphQL Schema\n" +
                            "# Generated by TARS\n\n" +
                            $"type {name} {{\n" +
                            "  id: ID!\n" +
                            "  name: String!\n" +
                            "  created: String!\n" +
                            "}\n\n" +
                            "type Query {\n" +
                            $"  {nameLower}s: [{name}!]!\n" +
                            $"  {nameLower}(id: ID!): {name}\n" +
                            "}\n\n" +
                            "type Mutation {\n" +
                            $"  create{name}(name: String!): {name}!\n" +
                            $"  update{name}(id: ID!, name: String!): {name}!\n" +
                            $"  delete{name}(id: ID!): Boolean!\n" +
                            "}"
                        
                        File.WriteAllText(graphqlFile, schemaContent)
                        
                        return Ok {|
                            Type = "HYBRID_API"
                            Name = name
                            OutputDirectory = outputDir
                            BaseUrl = "http://localhost:5000"
                            RestEndpoints = 6
                            GraphQLTypes = 3
                            SwaggerEnabled = true
                            GraphQLEnabled = true
                            GeneratedFiles = restData.GeneratedFiles @ [graphqlFile]
                        |}
                    | Error err ->
                        return Error err
                    
                with ex ->
                    return Error $"Failed to generate hybrid API: {ex.Message}"
            }
    
    /// Get available closure types
    member _.GetAvailableClosureTypes() =
        [
            "REST_ENDPOINT"
            "GRAPHQL_SERVER"
            "GRAPHQL_CLIENT"
            "HYBRID_API"
        ]
    
    /// Create a closure based on type
    member this.CreateClosure(closureType: string, name: string, config: Map<string, obj>) =
        match closureType.ToUpper() with
        | "REST_ENDPOINT" -> this.CreateRestEndpointClosure(name, config)
        | "GRAPHQL_SERVER" -> this.CreateGraphQLServerClosure(name, config)
        | "GRAPHQL_CLIENT" -> 
            let schemaUrl = config.TryFind("schemaUrl") |> Option.map string |> Option.defaultValue "http://localhost:5000/graphql"
            this.CreateGraphQLClientClosure(name, schemaUrl)
        | "HYBRID_API" -> this.CreateHybridApiClosure(name, config)
        | _ -> fun _ -> async { return Error $"Unknown closure type: {closureType}" }
