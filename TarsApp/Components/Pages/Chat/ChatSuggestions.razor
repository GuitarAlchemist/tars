@inject IChatClient ChatClient
@using MudBlazor

@if (suggestions.Count > 0)
{
    <MudGrid Class="mb-4">
        @foreach (var suggestion in suggestions)
        {
            <MudItem xs="12" sm="6" md="4">
                <MudButton Variant="Variant.Outlined" 
                          Color="Color.Primary" 
                          FullWidth="true"
                          OnClick="@(() => SelectSuggestionAsync(suggestion))">
                    @suggestion
                </MudButton>
            </MudItem>
        }
    </MudGrid>
}

@code {
    private static string Prompt = @"
        Suggest up to 3 follow-up questions that I could ask you to help me complete my task.
        Each suggestion must be a complete sentence, maximum 6 words.
        Each suggestion must be phrased as something that I (the user) would ask you (the assistant) in response to your previous message,
        for example 'How do I do that?' or 'Explain ...'.
        If there are no suggestions, reply with an empty list.
    ";

    private readonly List<string> suggestions = new();
    private CancellationTokenSource? cancellation;

    [Parameter]
    public EventCallback<ChatMessage> OnSelected { get; set; }

    public void Clear()
    {
        suggestions.Clear();
        cancellation?.Cancel();
        StateHasChanged();
    }

    public void Update(IReadOnlyList<ChatMessage> messages)
    {
        // Runs in the background and handles its own cancellation/errors
        _ = UpdateSuggestionsAsync(messages);
    }

    private async Task UpdateSuggestionsAsync(IReadOnlyList<ChatMessage> messages)
    {
        cancellation?.Cancel();
        cancellation = new CancellationTokenSource();

        try
        {
            // Prepare messages and options
            var messagesToSend = ReduceMessages(messages).Append(new ChatMessage(ChatRole.User, Prompt));
            var options = new ChatOptions { Temperature = 0.7f };

            // Call the API with correct parameters
            var response = await ChatClient.GetResponseAsync<string[]>(
                messagesToSend,
                options,
                null,  // This parameter is likely for streaming
                cancellation.Token);

            suggestions.Clear();
            if (response.TryGetResult(out var newSuggestions))
            {
                suggestions.AddRange(newSuggestions);
            }

            StateHasChanged();
        }
        catch (Exception ex) when (ex is not OperationCanceledException)
        {
            // Handle exception
            await Console.Error.WriteLineAsync($"Error generating suggestions: {ex.Message}");
            suggestions.Clear();
            StateHasChanged();
        }
    }

    private async Task SelectSuggestionAsync(string text)
    {
        await OnSelected.InvokeAsync(new ChatMessage(ChatRole.User, text));
    }

    private IEnumerable<ChatMessage> ReduceMessages(IReadOnlyList<ChatMessage> messages)
    {
        // Get any leading system messages, plus up to 5 user/assistant messages
        // This should be enough context to generate suggestions without unnecessarily resending entire conversations when long
        var systemMessages = messages.TakeWhile(m => m.Role == ChatRole.System);
        var otherMessages = messages.Where(m => m.Role == ChatRole.User || m.Role == ChatRole.Assistant)
                                   .Where(m => !string.IsNullOrEmpty(m.Text))
                                   .TakeLast(5);
        return systemMessages.Concat(otherMessages);
    }
}
