using System.Text.RegularExpressions;

namespace TarsCli.Services.CodeAnalysis;

/// <summary>
/// Analyzer for security vulnerabilities in code
/// </summary>
public class SecurityVulnerabilityAnalyzer
{
    private readonly ILogger<SecurityVulnerabilityAnalyzer> _logger;

    /// <summary>
    /// Initializes a new instance of the SecurityVulnerabilityAnalyzer class
    /// </summary>
    /// <param name="logger">Logger instance</param>
    public SecurityVulnerabilityAnalyzer(ILogger<SecurityVulnerabilityAnalyzer> logger)
    {
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
    }

    /// <summary>
    /// Analyzes a file for security vulnerabilities
    /// </summary>
    /// <param name="filePath">Path to the file</param>
    /// <param name="fileContent">Content of the file</param>
    /// <param name="fileType">Type of the file (e.g., "cs", "fs")</param>
    /// <returns>List of security issues found</returns>
    public async Task<List<CodeIssue>> AnalyzeAsync(string filePath, string fileContent, string fileType)
    {
        _logger.LogInformation($"Analyzing file for security vulnerabilities: {filePath}");

        var issues = new List<CodeIssue>();

        try
        {
            // Split the file content into lines for analysis
            var lines = fileContent.Split(["\r\n", "\r", "\n"], StringSplitOptions.None);

            // Check for SQL injection vulnerabilities
            await CheckSqlInjectionAsync(lines, issues, fileType);

            // Check for cross-site scripting (XSS) vulnerabilities
            await CheckXssVulnerabilitiesAsync(lines, issues, fileType);

            // Check for insecure deserialization
            await CheckInsecureDeserializationAsync(lines, issues, fileType);

            // Check for hardcoded credentials
            await CheckHardcodedCredentialsAsync(lines, issues, fileType);

            // Check for insecure cryptography
            await CheckInsecureCryptographyAsync(lines, issues, fileType);

            // Check for path traversal vulnerabilities
            await CheckPathTraversalAsync(lines, issues, fileType);

            _logger.LogInformation($"Security analysis completed for {filePath}. Found {issues.Count} security issues.");
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, $"Error analyzing file for security vulnerabilities: {filePath}");
            issues.Add(new CodeIssue
            {
                Type = CodeIssueType.Security,
                Severity = IssueSeverity.Error,
                Description = $"Error analyzing file for security vulnerabilities: {ex.Message}",
                LineNumber = 1,
                ColumnNumber = 1
            });
        }

        return issues;
    }

    /// <summary>
    /// Checks for SQL injection vulnerabilities
    /// </summary>
    /// <param name="lines">Lines of code</param>
    /// <param name="issues">List of issues to add to</param>
    /// <param name="fileType">Type of the file</param>
    private async Task CheckSqlInjectionAsync(string[] lines, List<CodeIssue> issues, string fileType)
    {
        // Patterns that might indicate SQL injection vulnerabilities
        var patterns = new List<Regex>();

        if (fileType == "cs")
        {
            patterns.Add(new Regex(@"string\s+sql\s*=.*\+"));
            patterns.Add(new Regex(@"ExecuteQuery\s*\(\s*.*\+"));
            patterns.Add(new Regex(@"ExecuteNonQuery\s*\(\s*.*\+"));
            patterns.Add(new Regex(@"ExecuteScalar\s*\(\s*.*\+"));
            patterns.Add(new Regex(@"SqlCommand\s*\(\s*.*\+"));
        }
        else if (fileType == "fs")
        {
            patterns.Add(new Regex(@"let\s+sql\s*=.*\+"));
            patterns.Add(new Regex(@"ExecuteQuery\s*\(\s*.*\+"));
            patterns.Add(new Regex(@"ExecuteNonQuery\s*\(\s*.*\+"));
            patterns.Add(new Regex(@"ExecuteScalar\s*\(\s*.*\+"));
            patterns.Add(new Regex(@"SqlCommand\s*\(\s*.*\+"));
        }

        for (var i = 0; i < lines.Length; i++)
        {
            var line = lines[i];

            foreach (var pattern in patterns)
            {
                if (pattern.IsMatch(line))
                {
                    // Check if the line contains parameterized queries
                    if (!line.Contains("Parameters.Add") && !line.Contains("@"))
                    {
                        issues.Add(new CodeIssue
                        {
                            Type = CodeIssueType.Security,
                            Severity = IssueSeverity.Critical,
                            Description = "Potential SQL injection vulnerability: String concatenation used in SQL query",
                            LineNumber = i + 1,
                            ColumnNumber = 1,
                            CodeSegment = line,
                            SuggestedFix = "// Use parameterized queries instead of string concatenation"
                        });
                    }
                }
            }
        }

        await Task.CompletedTask;
    }

    /// <summary>
    /// Checks for cross-site scripting (XSS) vulnerabilities
    /// </summary>
    /// <param name="lines">Lines of code</param>
    /// <param name="issues">List of issues to add to</param>
    /// <param name="fileType">Type of the file</param>
    private async Task CheckXssVulnerabilitiesAsync(string[] lines, List<CodeIssue> issues, string fileType)
    {
        // Patterns that might indicate XSS vulnerabilities
        var patterns = new List<Regex>();

        if (fileType == "cs")
        {
            patterns.Add(new Regex(@"Response\.Write\s*\(\s*.*\)"));
            patterns.Add(new Regex(@"innerHTML\s*="));
            patterns.Add(new Regex(@"document\.write\s*\(\s*.*\)"));
            patterns.Add(new Regex(@"eval\s*\(\s*.*\)"));
        }
        else if (fileType == "fs")
        {
            patterns.Add(new Regex(@"Response\.Write\s*\(\s*.*\)"));
            patterns.Add(new Regex(@"innerHTML\s*<-"));
            patterns.Add(new Regex(@"document\.write\s*\(\s*.*\)"));
            patterns.Add(new Regex(@"eval\s*\(\s*.*\)"));
        }

        for (var i = 0; i < lines.Length; i++)
        {
            var line = lines[i];

            foreach (var pattern in patterns)
            {
                if (pattern.IsMatch(line))
                {
                    // Check if the line contains proper encoding
                    if (!line.Contains("HtmlEncode") && !line.Contains("UrlEncode") && !line.Contains("JavaScriptEncode"))
                    {
                        issues.Add(new CodeIssue
                        {
                            Type = CodeIssueType.Security,
                            Severity = IssueSeverity.Critical,
                            Description = "Potential cross-site scripting (XSS) vulnerability: Unencoded output",
                            LineNumber = i + 1,
                            ColumnNumber = 1,
                            CodeSegment = line,
                            SuggestedFix = "// Use proper encoding functions like HtmlEncode, UrlEncode, or JavaScriptEncode"
                        });
                    }
                }
            }
        }

        await Task.CompletedTask;
    }

    /// <summary>
    /// Checks for insecure deserialization vulnerabilities
    /// </summary>
    /// <param name="lines">Lines of code</param>
    /// <param name="issues">List of issues to add to</param>
    /// <param name="fileType">Type of the file</param>
    private async Task CheckInsecureDeserializationAsync(string[] lines, List<CodeIssue> issues, string fileType)
    {
        // Patterns that might indicate insecure deserialization
        var patterns = new List<Regex>();

        if (fileType == "cs")
        {
            patterns.Add(new Regex(@"BinaryFormatter"));
            patterns.Add(new Regex(@"JavaScriptSerializer"));
            patterns.Add(new Regex(@"XmlSerializer\s*\(\s*.*\)"));
            patterns.Add(new Regex(@"DataContractSerializer"));
            patterns.Add(new Regex(@"NetDataContractSerializer"));
            patterns.Add(new Regex(@"SoapFormatter"));
        }
        else if (fileType == "fs")
        {
            patterns.Add(new Regex(@"BinaryFormatter"));
            patterns.Add(new Regex(@"JavaScriptSerializer"));
            patterns.Add(new Regex(@"XmlSerializer\s*\(\s*.*\)"));
            patterns.Add(new Regex(@"DataContractSerializer"));
            patterns.Add(new Regex(@"NetDataContractSerializer"));
            patterns.Add(new Regex(@"SoapFormatter"));
        }

        for (var i = 0; i < lines.Length; i++)
        {
            var line = lines[i];

            foreach (var pattern in patterns)
            {
                if (pattern.IsMatch(line))
                {
                    issues.Add(new CodeIssue
                    {
                        Type = CodeIssueType.Security,
                        Severity = IssueSeverity.Critical,
                        Description = "Potential insecure deserialization vulnerability",
                        LineNumber = i + 1,
                        ColumnNumber = 1,
                        CodeSegment = line,
                        SuggestedFix = "// Use secure serialization methods like System.Text.Json or Newtonsoft.Json with appropriate settings"
                    });
                }
            }
        }

        await Task.CompletedTask;
    }

    /// <summary>
    /// Checks for hardcoded credentials
    /// </summary>
    /// <param name="lines">Lines of code</param>
    /// <param name="issues">List of issues to add to</param>
    /// <param name="fileType">Type of the file</param>
    private async Task CheckHardcodedCredentialsAsync(string[] lines, List<CodeIssue> issues, string fileType)
    {
        // Patterns that might indicate hardcoded credentials
        var patterns = new List<Regex>();

        patterns.Add(new Regex(@"password\s*=\s*[""'].*[""']", RegexOptions.IgnoreCase));
        patterns.Add(new Regex(@"pwd\s*=\s*[""'].*[""']", RegexOptions.IgnoreCase));
        patterns.Add(new Regex(@"passwd\s*=\s*[""'].*[""']", RegexOptions.IgnoreCase));
        patterns.Add(new Regex(@"apikey\s*=\s*[""'].*[""']", RegexOptions.IgnoreCase));
        patterns.Add(new Regex(@"api_key\s*=\s*[""'].*[""']", RegexOptions.IgnoreCase));
        patterns.Add(new Regex(@"secret\s*=\s*[""'].*[""']", RegexOptions.IgnoreCase));
        patterns.Add(new Regex(@"connectionstring\s*=\s*[""'].*password=.*[""']", RegexOptions.IgnoreCase));

        for (var i = 0; i < lines.Length; i++)
        {
            var line = lines[i];

            // Skip comments
            if (line.Trim().StartsWith("//") || line.Trim().StartsWith("/*") || line.Trim().StartsWith("*"))
            {
                continue;
            }

            foreach (var pattern in patterns)
            {
                if (pattern.IsMatch(line))
                {
                    issues.Add(new CodeIssue
                    {
                        Type = CodeIssueType.Security,
                        Severity = IssueSeverity.Critical,
                        Description = "Hardcoded credentials detected",
                        LineNumber = i + 1,
                        ColumnNumber = 1,
                        CodeSegment = line,
                        SuggestedFix = "// Store credentials in a secure configuration system or environment variables"
                    });
                }
            }
        }

        await Task.CompletedTask;
    }

    /// <summary>
    /// Checks for insecure cryptography
    /// </summary>
    /// <param name="lines">Lines of code</param>
    /// <param name="issues">List of issues to add to</param>
    /// <param name="fileType">Type of the file</param>
    private async Task CheckInsecureCryptographyAsync(string[] lines, List<CodeIssue> issues, string fileType)
    {
        // Patterns that might indicate insecure cryptography
        var patterns = new List<Regex>();

        patterns.Add(new Regex(@"MD5", RegexOptions.IgnoreCase));
        patterns.Add(new Regex(@"SHA1", RegexOptions.IgnoreCase));
        patterns.Add(new Regex(@"DES", RegexOptions.IgnoreCase));
        patterns.Add(new Regex(@"TripleDES", RegexOptions.IgnoreCase));
        patterns.Add(new Regex(@"RC2", RegexOptions.IgnoreCase));

        for (var i = 0; i < lines.Length; i++)
        {
            var line = lines[i];

            foreach (var pattern in patterns)
            {
                if (pattern.IsMatch(line))
                {
                    issues.Add(new CodeIssue
                    {
                        Type = CodeIssueType.Security,
                        Severity = IssueSeverity.Critical,
                        Description = "Insecure cryptographic algorithm detected",
                        LineNumber = i + 1,
                        ColumnNumber = 1,
                        CodeSegment = line,
                        SuggestedFix = "// Use secure cryptographic algorithms like SHA256, SHA512, AES, or RSA"
                    });
                }
            }
        }

        await Task.CompletedTask;
    }

    /// <summary>
    /// Checks for path traversal vulnerabilities
    /// </summary>
    /// <param name="lines">Lines of code</param>
    /// <param name="issues">List of issues to add to</param>
    /// <param name="fileType">Type of the file</param>
    private async Task CheckPathTraversalAsync(string[] lines, List<CodeIssue> issues, string fileType)
    {
        // Patterns that might indicate path traversal vulnerabilities
        var patterns = new List<Regex>();

        if (fileType == "cs")
        {
            patterns.Add(new Regex(@"File\.Open\s*\(\s*.*\)"));
            patterns.Add(new Regex(@"File\.ReadAllText\s*\(\s*.*\)"));
            patterns.Add(new Regex(@"File\.WriteAllText\s*\(\s*.*\)"));
            patterns.Add(new Regex(@"new FileStream\s*\(\s*.*\)"));
        }
        else if (fileType == "fs")
        {
            patterns.Add(new Regex(@"File\.Open\s*\(\s*.*\)"));
            patterns.Add(new Regex(@"File\.ReadAllText\s*\(\s*.*\)"));
            patterns.Add(new Regex(@"File\.WriteAllText\s*\(\s*.*\)"));
            patterns.Add(new Regex(@"new FileStream\s*\(\s*.*\)"));
        }

        for (var i = 0; i < lines.Length; i++)
        {
            var line = lines[i];

            foreach (var pattern in patterns)
            {
                if (pattern.IsMatch(line))
                {
                    // Check if the line contains user input without validation
                    if (line.Contains("Request.") || line.Contains("QueryString") || line.Contains("Form["))
                    {
                        // Check if the line contains path validation
                        if (!line.Contains("Path.GetFullPath") && !line.Contains("Path.Combine"))
                        {
                            issues.Add(new CodeIssue
                            {
                                Type = CodeIssueType.Security,
                                Severity = IssueSeverity.Critical,
                                Description = "Potential path traversal vulnerability: User input used in file operations without validation",
                                LineNumber = i + 1,
                                ColumnNumber = 1,
                                CodeSegment = line,
                                SuggestedFix = "// Validate and sanitize user input before using it in file operations"
                            });
                        }
                    }
                }
            }
        }

        await Task.CompletedTask;
    }
}