using System.Text.Json;
using Microsoft.Extensions.Logging;
using TarsEngine.Models;

namespace TarsEngine.Services;

/// <summary>
/// Service for analyzing code for security vulnerabilities
/// </summary>
public class SecurityVulnerabilityAnalyzer
{
    private readonly ILogger<SecurityVulnerabilityAnalyzer> _logger;
    private readonly LlmService _llmService;

    /// <summary>
    /// Initializes a new instance of the SecurityVulnerabilityAnalyzer class
    /// </summary>
    /// <param name="logger">Logger instance</param>
    /// <param name="llmService">LLM service</param>
    public SecurityVulnerabilityAnalyzer(
        ILogger<SecurityVulnerabilityAnalyzer> logger,
        LlmService llmService)
    {
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
        _llmService = llmService ?? throw new ArgumentNullException(nameof(llmService));
    }

    /// <summary>
    /// Analyzes code for security vulnerabilities
    /// </summary>
    /// <param name="fileContent">The file content</param>
    /// <param name="language">The language</param>
    /// <param name="model">The model to use (optional)</param>
    /// <returns>The security vulnerabilities</returns>
    public async Task<List<SecurityVulnerability>> AnalyzeAsync(string fileContent, string language, string model = "llama3")
    {
        try
        {
            _logger.LogInformation($"Analyzing {language} code for security vulnerabilities");

            // Create a prompt for the LLM
            var prompt = $@"Analyze the following {language} code for security vulnerabilities.

Code:
```{language}
{fileContent}
```

Identify any security vulnerabilities in the code, such as:
1. Injection vulnerabilities (SQL, command, etc.)
2. Cross-site scripting (XSS)
3. Cross-site request forgery (CSRF)
4. Insecure direct object references
5. Security misconfiguration
6. Sensitive data exposure
7. Missing function level access control
8. Cross-origin resource sharing (CORS) misconfiguration
9. Unvalidated redirects and forwards
10. Insecure cryptographic storage
11. Insufficient transport layer protection
12. Improper error handling
13. Insecure deserialization
14. Using components with known vulnerabilities
15. Hardcoded credentials
16. Weak authentication
17. Weak password storage
18. Race conditions
19. Buffer overflows
20. Integer overflows
21. Format string vulnerabilities
22. Memory leaks
23. Uncontrolled resource consumption
24. Improper input validation
25. Improper output encoding

For each vulnerability, provide:
1. The name of the vulnerability
2. A description of the vulnerability
3. The severity (Low, Medium, High, Critical)
4. The location in the code (line number if possible)
5. The code snippet containing the vulnerability
6. A recommended fix
7. CWE ID (if applicable)
8. OWASP category (if applicable)
9. References (if applicable)

Format your response as a JSON array of objects with the following structure:
[
  {{
    ""name"": ""Vulnerability name"",
    ""description"": ""Description of the vulnerability"",
    ""severity"": ""Critical"", // Low, Medium, High, Critical
    ""location"": ""Location in the code (e.g., line number, method name)"",
    ""lineNumber"": 42, // Line number where the vulnerability was found
    ""columnNumber"": 10, // Column number where the vulnerability was found
    ""codeSnippet"": ""Code snippet containing the vulnerability"",
    ""recommendedFix"": ""Recommended fix for the vulnerability"",
    ""cweId"": ""CWE-79"", // CWE ID (if applicable)
    ""owaspCategory"": ""Injection"", // OWASP category (if applicable)
    ""references"": [""https://example.com/reference1"", ""https://example.com/reference2""] // References (if applicable)
  }}
]

If no vulnerabilities are found, return an empty array.";

            // Generate the vulnerabilities
            var vulnerabilitiesJson = await _llmService.GetCompletionAsync(prompt, temperature: 0.2, maxTokens: 2000, model: model);

            // Parse the vulnerabilities
            try
            {
                var vulnerabilities = JsonSerializer.Deserialize<List<SecurityVulnerability>>(vulnerabilitiesJson);
                return vulnerabilities ?? new List<SecurityVulnerability>();
            }
            catch (JsonException ex)
            {
                _logger.LogError(ex, "Failed to parse security vulnerabilities");
                return new List<SecurityVulnerability>();
            }
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error analyzing code for security vulnerabilities");
            return new List<SecurityVulnerability>();
        }
    }
}
