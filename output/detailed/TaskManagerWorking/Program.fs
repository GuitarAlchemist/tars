open System
open System.IO
open System.Text.Json

// ============================================================================
// COMPREHENSIVE TASK MANAGER APPLICATION - GENERATED BY TARS
// ============================================================================
// Features: Categories, Priorities, Due Dates, Notifications, JSON Persistence
// Patterns: Observer Pattern, LINQ Operations, Error Handling
// ============================================================================

// Domain Models
type Priority = High | Medium | Low

type TaskCategory = {
    Id: Guid
    Name: string
    Color: string
    CreatedAt: DateTime
}

type TaskItem = {
    Id: Guid
    Title: string
    Description: string
    Category: TaskCategory option
    Priority: Priority
    DueDate: DateTime option
    IsCompleted: bool
    CreatedAt: DateTime
    CompletedAt: DateTime option
    Tags: string list
}

// Observer Pattern Implementation
type ITaskObserver =
    abstract member OnTaskAdded: TaskItem -> unit
    abstract member OnTaskCompleted: TaskItem -> unit
    abstract member OnTaskDeleted: TaskItem -> unit

// Notification Observer
type NotificationObserver() =
    interface ITaskObserver with
        member _.OnTaskAdded(task) =
            printfn "üîî New task added: %s" task.Title
            
        member _.OnTaskCompleted(task) =
            printfn "‚úÖ Task completed: %s" task.Title
            
        member _.OnTaskDeleted(task) =
            printfn "üóëÔ∏è Task deleted: %s" task.Title

// Analytics Observer
type AnalyticsObserver() =
    let mutable completedCount = 0
    let mutable totalTasks = 0
    
    interface ITaskObserver with
        member _.OnTaskAdded(task) =
            totalTasks <- totalTasks + 1
            printfn "üìä Analytics: Total tasks = %d" totalTasks
            
        member _.OnTaskCompleted(task) =
            completedCount <- completedCount + 1
            let completionRate = (float completedCount / float totalTasks) * 100.0
            printfn "üìà Analytics: Completion rate = %.1f%%" completionRate
            
        member _.OnTaskDeleted(task) =
            totalTasks <- totalTasks - 1

// File Manager for JSON Persistence
type FileManager(filePath: string) =
    let ensureDirectoryExists() =
        let directory = Path.GetDirectoryName(filePath)
        if not (Directory.Exists(directory)) then
            Directory.CreateDirectory(directory) |> ignore
    
    member _.SaveTasks(tasks: TaskItem list, categories: TaskCategory list) =
        try
            ensureDirectoryExists()
            let data = {| Tasks = tasks; Categories = categories; SavedAt = DateTime.UtcNow |}
            let json = JsonSerializer.Serialize(data, JsonSerializerOptions(WriteIndented = true))
            File.WriteAllText(filePath, json)
            Ok "Tasks saved successfully"
        with
        | ex -> Error (sprintf "Failed to save tasks: %s" ex.Message)
    
    member _.LoadTasks() =
        try
            if File.Exists(filePath) then
                let json = File.ReadAllText(filePath)
                let data = JsonSerializer.Deserialize<{| Tasks: TaskItem list; Categories: TaskCategory list |}>(json)
                Ok (data.Tasks, data.Categories)
            else
                Ok ([], [])
        with
        | ex -> Error (sprintf "Failed to load tasks: %s" ex.Message)

// Main Task Manager Class
type TaskManager(fileManager: FileManager) =
    let mutable tasks: TaskItem list = []
    let mutable categories: TaskCategory list = []
    let mutable observers: ITaskObserver list = []
    
    // Observer Management
    member _.AddObserver(observer: ITaskObserver) =
        observers <- observer :: observers
    
    member private _.NotifyTaskAdded(task: TaskItem) =
        observers |> List.iter (fun o -> o.OnTaskAdded(task))
    
    member private _.NotifyTaskCompleted(task: TaskItem) =
        observers |> List.iter (fun o -> o.OnTaskCompleted(task))
    
    member private _.NotifyTaskDeleted(task: TaskItem) =
        observers |> List.iter (fun o -> o.OnTaskDeleted(task))
    
    // Category Management
    member _.AddCategory(name: string, color: string) =
        let category = {
            Id = Guid.NewGuid()
            Name = name
            Color = color
            CreatedAt = DateTime.UtcNow
        }
        categories <- category :: categories
        category
    
    member _.GetCategories() = categories
    
    // Task Management
    member this.AddTask(title: string, description: string, priority: Priority, ?category: TaskCategory, ?dueDate: DateTime, ?tags: string list) =
        let task = {
            Id = Guid.NewGuid()
            Title = title
            Description = description
            Category = category
            Priority = priority
            DueDate = dueDate
            IsCompleted = false
            CreatedAt = DateTime.UtcNow
            CompletedAt = None
            Tags = defaultArg tags []
        }
        tasks <- task :: tasks
        this.NotifyTaskAdded(task)
        this.AutoSave()
        task
    
    member this.CompleteTask(taskId: Guid) =
        match tasks |> List.tryFind (fun t -> t.Id = taskId) with
        | Some task when not task.IsCompleted ->
            let completedTask = { task with IsCompleted = true; CompletedAt = Some DateTime.UtcNow }
            tasks <- tasks |> List.map (fun t -> if t.Id = taskId then completedTask else t)
            this.NotifyTaskCompleted(completedTask)
            this.AutoSave()
            Ok completedTask
        | Some _ -> Error "Task is already completed"
        | None -> Error "Task not found"
    
    member this.DeleteTask(taskId: Guid) =
        match tasks |> List.tryFind (fun t -> t.Id = taskId) with
        | Some task ->
            tasks <- tasks |> List.filter (fun t -> t.Id <> taskId)
            this.NotifyTaskDeleted(task)
            this.AutoSave()
            Ok "Task deleted successfully"
        | None -> Error "Task not found"
    
    // LINQ-style Query Operations
    member _.GetTasks() = tasks
    
    member _.GetTasksByCategory(categoryId: Guid) =
        tasks |> List.filter (fun t -> 
            match t.Category with
            | Some cat -> cat.Id = categoryId
            | None -> false)
    
    member _.GetTasksByPriority(priority: Priority) =
        tasks |> List.filter (fun t -> t.Priority = priority)
    
    member _.GetOverdueTasks() =
        let now = DateTime.UtcNow
        tasks |> List.filter (fun t -> 
            not t.IsCompleted && 
            match t.DueDate with
            | Some due -> due < now
            | None -> false)
    
    member _.GetTasksDueToday() =
        let today = DateTime.Today
        let tomorrow = today.AddDays(1.0)
        tasks |> List.filter (fun t ->
            not t.IsCompleted &&
            match t.DueDate with
            | Some due -> due >= today && due < tomorrow
            | None -> false)
    
    member _.SearchTasks(query: string) =
        let lowerQuery = query.ToLower()
        tasks |> List.filter (fun t ->
            t.Title.ToLower().Contains(lowerQuery) ||
            t.Description.ToLower().Contains(lowerQuery) ||
            t.Tags |> List.exists (fun tag -> tag.ToLower().Contains(lowerQuery)))
    
    member _.GetTaskStatistics() =
        let total = tasks.Length
        let completed = tasks |> List.filter (fun t -> t.IsCompleted) |> List.length
        let overdue = this.GetOverdueTasks().Length
        let dueToday = this.GetTasksDueToday().Length
        
        {|
            Total = total
            Completed = completed
            Pending = total - completed
            Overdue = overdue
            DueToday = dueToday
            CompletionRate = if total > 0 then (float completed / float total) * 100.0 else 0.0
        |}
    
    // Persistence
    member private _.AutoSave() =
        match fileManager.SaveTasks(tasks, categories) with
        | Ok _ -> ()
        | Error msg -> printfn "‚ö†Ô∏è Auto-save failed: %s" msg
    
    member _.LoadData() =
        match fileManager.LoadTasks() with
        | Ok (loadedTasks, loadedCategories) ->
            tasks <- loadedTasks
            categories <- loadedCategories
            Ok (sprintf "Loaded %d tasks and %d categories" tasks.Length categories.Length)
        | Error msg -> Error msg

// Demo Application
[<EntryPoint>]
let main argv =
    printfn "üöÄ COMPREHENSIVE TASK MANAGER - GENERATED BY TARS"
    printfn "=================================================="
    printfn ""
    
    // Initialize components
    let fileManager = FileManager("data/tasks.json")
    let taskManager = TaskManager(fileManager)
    
    // Add observers
    let notificationObserver = NotificationObserver()
    let analyticsObserver = AnalyticsObserver()
    taskManager.AddObserver(notificationObserver)
    taskManager.AddObserver(analyticsObserver)
    
    // Load existing data
    match taskManager.LoadData() with
    | Ok msg -> printfn "üìÇ %s" msg
    | Error msg -> printfn "‚ö†Ô∏è %s" msg
    
    // Create categories
    let workCategory = taskManager.AddCategory("Work", "#FF6B6B")
    let personalCategory = taskManager.AddCategory("Personal", "#4ECDC4")
    let shoppingCategory = taskManager.AddCategory("Shopping", "#45B7D1")
    
    printfn ""
    printfn "üìÅ Categories created:"
    taskManager.GetCategories() |> List.iter (fun cat ->
        printfn "  ‚Ä¢ %s (%s)" cat.Name cat.Color)
    
    // Add sample tasks
    printfn ""
    printfn "‚ûï Adding sample tasks..."
    
    let task1 = taskManager.AddTask("Complete project proposal", "Write and review the Q2 project proposal", High, workCategory, Some (DateTime.Today.AddDays(2.0)), ["urgent"; "project"])
    let task2 = taskManager.AddTask("Buy groceries", "Milk, bread, eggs, vegetables", Medium, personalCategory, Some (DateTime.Today.AddDays(1.0)), ["shopping"; "food"])
    let task3 = taskManager.AddTask("Call dentist", "Schedule annual checkup appointment", Low, personalCategory, Some (DateTime.Today.AddDays(7.0)), ["health"])
    let task4 = taskManager.AddTask("Review code", "Review pull requests from team", High, workCategory, Some (DateTime.Today), ["code"; "review"])
    
    // Demonstrate operations
    printfn ""
    printfn "üìä Current Statistics:"
    let stats = taskManager.GetTaskStatistics()
    printfn "  Total: %d | Completed: %d | Pending: %d" stats.Total stats.Completed stats.Pending
    printfn "  Overdue: %d | Due Today: %d | Completion Rate: %.1f%%" stats.Overdue stats.DueToday stats.CompletionRate
    
    // Complete a task
    printfn ""
    printfn "‚úÖ Completing a task..."
    match taskManager.CompleteTask(task4.Id) with
    | Ok _ -> printfn "Task completed successfully!"
    | Error msg -> printfn "Error: %s" msg
    
    // Show overdue and due today tasks
    printfn ""
    printfn "‚ö†Ô∏è Tasks due today:"
    taskManager.GetTasksDueToday() |> List.iter (fun t ->
        printfn "  ‚Ä¢ %s (Priority: %A)" t.Title t.Priority)
    
    printfn ""
    printfn "üîç Search results for 'project':"
    taskManager.SearchTasks("project") |> List.iter (fun t ->
        printfn "  ‚Ä¢ %s - %s" t.Title t.Description)
    
    // Final statistics
    printfn ""
    printfn "üìà Final Statistics:"
    let finalStats = taskManager.GetTaskStatistics()
    printfn "  Total: %d | Completed: %d | Pending: %d" finalStats.Total finalStats.Completed finalStats.Pending
    printfn "  Completion Rate: %.1f%%" finalStats.CompletionRate
    
    printfn ""
    printfn "üíæ Data automatically saved to: data/tasks.json"
    printfn "‚úÖ TARS successfully generated a comprehensive task manager!"
    
    0
